#!/usr/bin/env python3
"""
Test suite to verify AI recommendations are actually generated by Gemini AI
"""

import sys
import os
import unittest
import json
from datetime import datetime, timedelta
from unittest.mock import patch, MagicMock

# Add the parent directory to the path so we can import our modules
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from app import create_app, db
from app.models import User, HealthData
from app.ai_services.health_ai import HealthAIService
from config import Config


class TestConfig(Config):
    """Test configuration"""
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    WTF_CSRF_ENABLED = False
    SECRET_KEY = 'test-secret-key'


class TestAIRecommendations(unittest.TestCase):
    """Test cases to verify AI recommendations authenticity"""

    def setUp(self):
        """Set up test environment"""
        self.app = create_app(TestConfig)
        self.app_context = self.app.app_context()
        self.app_context.push()
        self.client = self.app.test_client()
        
        db.create_all()
        
        # Create test user
        self.test_user = User(
            username='testuser',
            email='test@example.com'
        )
        self.test_user.set_password('testpassword')
        db.session.add(self.test_user)
        db.session.commit()
        
        # Create sample health data
        self.create_sample_health_data()
        
        # Initialize AI service
        self.ai_service = HealthAIService()

    def tearDown(self):
        """Clean up test environment"""
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def create_sample_health_data(self):
        """Create sample health data for testing"""
        health_data = HealthData(
            user_id=self.test_user.id,
            steps=7500,
            sleep_duration_hours=7.5,
            water_intake_liters=2.0,
            active_minutes=25,
            mood_score=6,
            heart_rate_avg=75,
            weight_kg=70.0,
            date_logged=datetime.utcnow()
        )
        db.session.add(health_data)
        db.session.commit()
        self.health_data = health_data

    def test_ai_service_initialization(self):
        """Test that AI service initializes with Gemini configuration"""
        self.assertIsNotNone(self.ai_service)
        self.assertTrue(hasattr(self.ai_service, 'model'))
        self.assertTrue(hasattr(self.ai_service, 'nlp'))

    def test_ai_response_structure(self):
        """Test that AI response has the expected structure"""
        # Login as test user
        with self.client.session_transaction() as sess:
            sess['user_id'] = str(self.test_user.id)
            sess['_fresh'] = True

        response = self.ai_service.generate_health_advice([self.health_data])
        
        # Verify response is a dictionary
        self.assertIsInstance(response, dict)
        
        # Verify required fields are present
        required_fields = ['insights', 'recommendations', 'quick_wins', 'concerns', 'motivation', 'source', 'generated_at']
        for field in required_fields:
            self.assertIn(field, response, f"Missing required field: {field}")
        
        # Verify source is gemini_ai
        self.assertEqual(response['source'], 'gemini_ai', "AI advice should be sourced from gemini_ai")
        
        # Verify timestamp format
        self.assertIsInstance(response['generated_at'], str)
        # Should be able to parse as ISO datetime
        datetime.fromisoformat(response['generated_at'])

    def test_ai_response_content_quality(self):
        """Test that AI response contains meaningful content"""
        response = self.ai_service.generate_health_advice([self.health_data])
        
        # Test insights
        self.assertIsInstance(response['insights'], list)
        self.assertGreater(len(response['insights']), 0, "Should have at least one insight")
        for insight in response['insights']:
            self.assertIsInstance(insight, str)
            self.assertGreater(len(insight.strip()), 10, "Insights should be meaningful text")
        
        # Test recommendations
        self.assertIsInstance(response['recommendations'], list)
        self.assertGreater(len(response['recommendations']), 0, "Should have at least one recommendation")
        for rec in response['recommendations']:
            self.assertIsInstance(rec, str)
            self.assertGreater(len(rec.strip()), 15, "Recommendations should be detailed")
        
        # Test quick wins
        self.assertIsInstance(response['quick_wins'], list)
        self.assertGreater(len(response['quick_wins']), 0, "Should have at least one quick win")
        for qw in response['quick_wins']:
            self.assertIsInstance(qw, str)
            self.assertGreater(len(qw.strip()), 5, "Quick wins should be actionable")
        
        # Test motivation
        self.assertIsInstance(response['motivation'], str)
        self.assertGreater(len(response['motivation'].strip()), 20, "Motivation should be substantial")

    def test_ai_response_personalization(self):
        """Test that AI response is personalized to the health data"""
        response = self.ai_service.generate_health_advice([self.health_data])
        
        # Convert response to string for content analysis
        response_text = json.dumps(response).lower()
        
        # Check for references to specific health metrics
        health_terms = ['water', 'sleep', 'steps', 'activity', 'mood', 'exercise']
        found_terms = [term for term in health_terms if term in response_text]
        self.assertGreater(len(found_terms), 2, "Response should reference multiple health aspects")

    def test_ai_response_consistency(self):
        """Test that AI generates consistent but not identical responses"""
        # Generate multiple responses
        response1 = self.ai_service.generate_health_advice([self.health_data])
        response2 = self.ai_service.generate_health_advice([self.health_data])
        
        # Both should have same structure
        self.assertEqual(response1.keys(), response2.keys())
        
        # Both should be from gemini_ai
        self.assertEqual(response1['source'], 'gemini_ai')
        self.assertEqual(response2['source'], 'gemini_ai')
        
        # Timestamps should be different (generated at different times)
        self.assertNotEqual(response1['generated_at'], response2['generated_at'])

    def test_ai_response_with_different_health_data(self):
        """Test that AI provides different advice for different health scenarios"""
        # Create poor health data
        poor_health = HealthData(
            user_id=self.test_user.id,
            steps=2000,  # Low steps
            sleep_duration_hours=5.0,  # Poor sleep
            water_intake_liters=0.5,  # Low water
            active_minutes=5,  # Low activity
            mood_score=3,  # Poor mood
            heart_rate_avg=85,
            weight_kg=70.0,
            date_logged=datetime.utcnow()
        )
        
        # Create excellent health data
        excellent_health = HealthData(
            user_id=self.test_user.id,
            steps=12000,  # High steps
            sleep_duration_hours=8.5,  # Great sleep
            water_intake_liters=3.0,  # Good water intake
            active_minutes=60,  # High activity
            mood_score=9,  # Great mood
            heart_rate_avg=65,
            weight_kg=70.0,
            date_logged=datetime.utcnow()
        )
        
        poor_response = self.ai_service.generate_health_advice([poor_health])
        excellent_response = self.ai_service.generate_health_advice([excellent_health])
        
        # Both should be from Gemini
        self.assertEqual(poor_response['source'], 'gemini_ai')
        self.assertEqual(excellent_response['source'], 'gemini_ai')
        
        # Responses should be different
        self.assertNotEqual(poor_response['motivation'], excellent_response['motivation'])
        
        # Poor health should have more concerns
        poor_text = json.dumps(poor_response).lower()
        excellent_text = json.dumps(excellent_response).lower()
        
        concern_words = ['improve', 'increase', 'more', 'better', 'low']
        poor_concerns = sum(1 for word in concern_words if word in poor_text)
        excellent_concerns = sum(1 for word in concern_words if word in excellent_text)
        
        # Poor health scenario should trigger more improvement suggestions
        self.assertGreater(poor_concerns, excellent_concerns * 0.5)

    def test_gemini_api_integration(self):
        """Test that we're actually calling Gemini API (not a mock)"""
        with patch('google.generativeai.GenerativeModel') as mock_model:
            # Setup mock
            mock_instance = MagicMock()
            mock_model.return_value = mock_instance
            mock_response = MagicMock()
            mock_response.text = json.dumps({
                'insights': ['Mock insight'],
                'recommendations': ['Mock recommendation'],
                'quick_wins': ['Mock quick win'],
                'concerns': ['Mock concern'],
                'motivation': 'Mock motivation'
            })
            mock_instance.generate_content.return_value = mock_response
            
            # Create new AI service instance (should use mock)
            ai_service = HealthAIService()
            response = ai_service.generate_health_advice([self.health_data])
            
            # Verify Gemini API was called
            mock_model.assert_called()
            mock_instance.generate_content.assert_called()
            
            # Verify response structure
            self.assertIn('source', response)
            self.assertEqual(response['source'], 'gemini_ai')

    def test_error_handling(self):
        """Test that AI service handles errors gracefully"""
        with patch.object(self.ai_service, 'model') as mock_model:
            # Simulate API error
            mock_model.generate_content.side_effect = Exception("API Error")
            
            response = self.ai_service.generate_health_advice([self.health_data])
            
            # Should return fallback response
            self.assertIsInstance(response, dict)
            self.assertIn('source', response)
            # Error case might use fallback or default source

    def test_dashboard_integration(self):
        """Test AI recommendations appear correctly on dashboard"""
        # Login
        login_response = self.client.post('/auth/login', data={
            'username': 'testuser',
            'password': 'testpassword'
        }, follow_redirects=True)
        
        self.assertEqual(login_response.status_code, 200)
        
        # Access dashboard
        dashboard_response = self.client.get('/dashboard')
        self.assertEqual(dashboard_response.status_code, 200)
        
        # Check for AI advice elements
        dashboard_html = dashboard_response.get_data(as_text=True)
        
        # Should contain AI advice section
        self.assertIn('AI-Powered Health Insights', dashboard_html)
        self.assertIn('Priority Recommendations', dashboard_html)
        self.assertIn('Quick Wins', dashboard_html)
        self.assertIn('Generated by AI Assistant', dashboard_html)

    def test_ai_advice_metadata(self):
        """Test AI advice contains proper metadata for verification"""
        response = self.ai_service.generate_health_advice([self.health_data])
        
        # Check source attribution
        self.assertEqual(response['source'], 'gemini_ai')
        
        # Check timestamp is recent (within last minute)
        generated_time = datetime.fromisoformat(response['generated_at'])
        time_diff = datetime.now() - generated_time
        self.assertLess(time_diff.total_seconds(), 60, "Timestamp should be recent")
        
        # Check for required disclaimer elements (when displayed)
        # This would be checked in template rendering

    def test_no_hardcoded_responses(self):
        """Test that responses are not hardcoded/static"""
        responses = []
        
        # Generate multiple responses with same data
        for i in range(3):
            response = self.ai_service.generate_health_advice([self.health_data])
            responses.append(response)
        
        # Check that responses have some variation
        # (Gemini may provide similar but not identical responses)
        motivations = [r['motivation'] for r in responses]
        
        # At minimum, timestamps should be different
        timestamps = [r['generated_at'] for r in responses]
        self.assertEqual(len(set(timestamps)), 3, "Each response should have unique timestamp")


if __name__ == '__main__':
    # Run the tests
    unittest.main(verbosity=2)
